<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uv.lock Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            line-height: 1.6; 
            margin: 0;
            padding: 20px; 
            background-color: #f8f9fa; 
            color: #212529; 
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
            min-height: calc(100vh - 40px);
        }
        
        .left-column {
            flex: 0 0 22%; /* Reduced from 30% to 22% */
            display: flex;
            flex-direction: column;
        }
        
        .right-column {
            flex: 0 0 78%; /* Increased from 70% to 78% */
            display: flex;
            flex-direction: column;
        }
        
        h1, h2 { color: #343a40; }
        
        .upload-section {
            background: white;
            padding: 15px; /* Reduced from 20px to 15px */
            border-radius: 8px;
            margin-bottom: 15px; /* Reduced from 20px to 15px */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .drop-zone {
            margin-top: 10px;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            text-align: center;
            transition: all 0.2s ease;
            background-color: #f8f9fa;
            cursor: pointer;
        }
        
        .drop-zone.drag-over {
            border-color: #007bff;
            background-color: rgba(0, 123, 255, 0.05);
        }
        
        .drop-zone-prompt {
            margin: 10px 0;
        }
        
        .drop-zone-prompt p {
            margin: 5px 0;
            color: #666;
            font-size: 14px;
        }
        
        .drop-zone-hint {
            font-size: 12px !important;
            color: #999 !important;
        }
        
        #file-input { 
            margin: 10px auto;
            padding: 6px;
            border: 1px dashed #ccc;
            border-radius: 6px;
            width: 80%; /* Reduced width */
            max-width: 220px;
            text-align: center;
            font-size: 13px;
            display: block;
            cursor: pointer;
        }
        
        .stats { 
            border-left: 3px solid #007bff; 
            padding-left: 15px; 
            margin: 20px 0; 
        }
        
        .controls {
            background: white;
            padding: 15px; /* Reduced from 20px to 15px */
            border-radius: 8px;
            margin-bottom: 15px; /* Reduced from 20px to 15px */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls h3 {
            margin-top: 0;
            color: #333;
        }
        
        .filter-input {
            padding: 6px 10px; /* Reduced from 8px 12px */
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            max-width: 280px; /* Reduced from 300px */
            font-size: 13px; /* Reduced from 14px */
        }
        
        .autocomplete-container {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 280px; /* Reduced from 300px */
        }
        
        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }
        
        .autocomplete-item:hover,
        .autocomplete-item.highlighted {
            background-color: #f8f9fa;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .package-name {
            font-weight: bold;
            color: #333;
        }
        
        .package-info {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        
        .btn {
            padding: 6px 12px; /* Reduced from 8px 16px */
            margin-left: 8px; /* Reduced from 10px */
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px; /* Reduced from 14px */
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn-reset {
            background: #6c757d;
        }
        
        .btn-reset:hover {
            background: #545b62;
        }
        
        .btn-download {
            background: #28a745;
            margin-left: 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .btn-download:hover {
            background: #218838;
        }
        
        .download-icon {
            font-weight: bold;
        }
        
        .switch-container {
            display: inline-flex;
            align-items: center;
            margin-left: 8px; /* Reduced from 20px */
            margin-top: 10px; /* Added to stack the toggle switch below buttons */
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            margin-right: 10px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #758ab4;
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        #clickActionLabel {
            font-size: 14px;
            color: #333;
            user-select: none;
        }
        
        .visualization-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #dependency-graph {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }
        
        .placeholder-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #adb5bd;
            font-size: 18px;
            text-align: center;
        }
        
        .node {
            cursor: pointer;
            stroke: #333;
            stroke-width: 1.5px;
        }
        
        .node:hover {
            stroke-width: 3px;
        }
        
        .node.source-type-git {
            fill: #ff7f0e;
        }
        
        .node.source-type-registry {
            fill: #2ca02c;
        }
        
        .node.source-type-unknown {
            fill: #d62728;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
            marker-end: url(#arrowhead);
        }
        
        .link.outgoing {
            stroke: #007bff;
            stroke-width: 2px;
            stroke-opacity: 1;
            marker-end: url(#arrowhead-outgoing);
        }

        .link.incoming {
            stroke: #ff6b6b;
            stroke-width: 2px;
            stroke-opacity: 1;
            marker-end: url(#arrowhead-incoming);
        }
        
        .arrowhead {
            fill: #999;
        }
        
        .arrowhead-outgoing {
            fill: #007bff;
        }

        .arrowhead-incoming {
            fill: #ff6b6b;
        }
        
        .node-label {
            font-size: 12px;
            font-family: Arial, sans-serif;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #333;
        }
        
        .file-info {
            display: none; /* Hidden by default */
            margin-top: 10px;
            background-color: rgba(0, 123, 255, 0.1);
            padding: 8px;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .file-info.active {
            display: block;
        }
        
        .file-name {
            font-weight: bold;
            word-break: break-all;
        }
        
        .file-info .success-icon {
            color: #28a745;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-column">
            <div class="upload-section">
                <h1>uv.lock Visualizer</h1>
                <div class="drop-zone" id="drop-zone">
                    <div class="drop-zone-prompt">
                        <p>Drag & drop a uv.lock file here<br>or</p>
                        <input type="file" id="file-input" accept=".lock">
                        <p class="drop-zone-hint">Only .lock files are accepted</p>
                    </div>
                    <div class="file-info" id="file-info">
                        <span class="success-icon">✓</span>
                        <span>File loaded: </span>
                        <span class="file-name" id="file-name"></span>
                    </div>
                </div>
                
                <div id="upload-results">
                    <div id="stats" class="stats"></div>
                </div>
            </div>
            
            <div class="controls" id="controls">
                <h3>Visualization Controls</h3>
                <div>
                    <div class="autocomplete-container">
                        <input type="text" class="filter-input" id="packageFilter" placeholder="Enter package name..." autocomplete="off">
                        <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                    </div>
                    <div style="margin-top: 8px;">
                        <button class="btn" onclick="filterDependencies()">Filter</button>
                        <button class="btn btn-reset" onclick="resetFilter()">Reset</button>
                    </div>
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="clickActionToggle">
                            <span class="slider"></span>
                        </label>
                        <span id="clickActionLabel">Click to expand neighbors</span>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-download" id="downloadPngBtn">
                            <span class="download-icon">⬇</span> Save as PNG
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="right-column">
            <div class="visualization-container" id="visualization-container">
                <svg id="dependency-graph"></svg>
                <div class="placeholder-message" id="placeholder-message">
                    Upload a uv.lock file to visualize dependencies
                </div>
                
                <div class="legend" id="legend">
                    <h4>Legend</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ca02c;"></div>
                        <span>Registry</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff7f0e;"></div>
                        <span>Git</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #d62728;"></div>
                        <span>Unknown</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global variables
        let allData = null;
        let displayedData = { nodes: [], edges: [] };
        let simulation = null;
        let selectedIndex = -1;
        let svg, container, link, node, labels;
        let clickAction = 'expand';

        function hideDropdown() {
            const dropdown = document.getElementById("autocompleteDropdown");
            dropdown.style.display = "none";
            selectedIndex = -1;
        }

        function showDropdown(matches, searchValue) {
            const dropdown = document.getElementById("autocompleteDropdown");
            dropdown.innerHTML = "";
            
            matches.forEach((node, index) => {
                const item = document.createElement("div");
                item.className = "autocomplete-item";
                item.dataset.packageName = node.name;
                
                const nameHtml = highlightMatch(node.name, searchValue);
                
                item.innerHTML = `
                    <div class="package-name">${nameHtml}</div>
                    <div class="package-info">v${node.version} • ${node.source_type} • ${node.dependency_count} dependencies</div>
                `;
                
                item.addEventListener("click", function() {
                    selectItem(node.name);
                });
                
                dropdown.appendChild(item);
            });
            
            dropdown.style.display = "block";
        }
        
        function updateSelection(items) {
            items.forEach((item, index) => {
                item.classList.toggle("highlighted", index === selectedIndex);
            });
        }
        
        function selectItem(packageName) {
            const input = document.getElementById("packageFilter");
            input.value = packageName;
            hideDropdown();
            filterDependencies();
        }
        
        function highlightMatch(text, searchValue) {
            if (!searchValue) return text;
            
            const regex = new RegExp(`(${escapeRegExp(searchValue)})`, "gi");
            return text.replace(regex, "<strong>$1</strong>");
        }
        
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function setupClickActionToggle() {
            const toggle = document.getElementById('clickActionToggle');
            const label = document.getElementById('clickActionLabel');
            
            toggle.addEventListener('change', function() {
                if (this.checked) {
                    clickAction = 'hide';
                    label.textContent = 'Click to hide node';
                } else {
                    clickAction = 'expand';
                    label.textContent = 'Click to expand neighbors';
                }
            });
        }

        function setupAutocomplete() {
            const input = document.getElementById("packageFilter");
            const dropdown = document.getElementById("autocompleteDropdown");
            
            input.addEventListener("input", function() {
                const value = this.value.toLowerCase().trim();
                selectedIndex = -1;
                
                if (value.length === 0) {
                    hideDropdown();
                    return;
                }
                
                const matches = allData.nodes.filter(node => 
                    node.name.toLowerCase().includes(value)
                ).slice(0, 10);
                
                if (matches.length === 0) {
                    hideDropdown();
                    return;
                }
                
                showDropdown(matches, value);
            });
            
            input.addEventListener("keydown", function(event) {
                const items = dropdown.querySelectorAll(".autocomplete-item");
                
                if (event.key === "ArrowDown") {
                    event.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (event.key === "ArrowUp") {
                    event.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (event.key === "Enter") {
                    event.preventDefault();
                    if (selectedIndex >= 0 && items[selectedIndex]) {
                        selectItem(items[selectedIndex].dataset.packageName);
                    } else {
                        filterDependencies();
                    }
                } else if (event.key === "Escape") {
                    hideDropdown();
                }
            });
            
            input.addEventListener("blur", function() {
                setTimeout(() => hideDropdown(), 150);
            });
            
            document.addEventListener("click", function(event) {
                if (!event.target.closest(".autocomplete-container")) {
                    hideDropdown();
                }
            });
        }

        // Initialize visualization immediately
        document.addEventListener('DOMContentLoaded', function() {
            initializeVisualization();
            setupClickActionToggle();
            setupDragAndDrop();
            setupDownloadButton();
        });

        /**
         * Sets up the download button to export visualization as PNG
         */
        function setupDownloadButton() {
            const downloadBtn = document.getElementById('downloadPngBtn');
            
            downloadBtn.addEventListener('click', function() {
                // Check if we have a visualization to download
                if (!allData || displayedData.nodes.length === 0) {
                    alert('No visualization to download. Please load a file first.');
                    return;
                }
                
                downloadVisualizationAsPng();
            });
        }
        
        /**
         * Converts the SVG visualization to PNG and triggers download
         */
        function downloadVisualizationAsPng() {
            const svgElement = document.getElementById('dependency-graph');
            const containerElement = document.getElementById('visualization-container');
            
            // Get dimensions
            const width = containerElement.clientWidth;
            const height = containerElement.clientHeight;
            
            // Create a clone of the SVG to avoid modifying the original
            const svgClone = svgElement.cloneNode(true);
            
            // Set proper dimensions and style
            svgClone.setAttribute('width', width);
            svgClone.setAttribute('height', height);
            
            // Prepare to create canvas with proper scaling
            const scale = 2; // Higher resolution for better quality
            const canvas = document.createElement('canvas');
            canvas.width = width * scale;
            canvas.height = height * scale;
            
            // Get canvas context and set white background
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.scale(scale, scale);
            
            // Create an image from the SVG
            const svgData = new XMLSerializer().serializeToString(svgElement);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                // Draw the image onto the canvas
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                
                // Convert canvas to data URL and trigger download
                try {
                    const pngData = canvas.toDataURL('image/png');
                    const downloadLink = document.createElement('a');
                    const filename = 'uv-lock-visualization-' + new Date().toISOString().slice(0, 10) + '.png';
                    
                    downloadLink.href = pngData;
                    downloadLink.download = filename;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                } catch (error) {
                    console.error('Error creating PNG:', error);
                    alert('Error creating PNG image. This might be due to security restrictions with local files.');
                }
            };
            
            img.src = url;
        }
        
        /**
         * Sets up drag and drop functionality for file uploads
         */
        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const fileInfo = document.getElementById('file-info');
            const fileNameText = document.getElementById('file-name');
            
            // Open file dialog when clicking on the drop zone
            dropZone.addEventListener('click', function(e) {
                // Prevent clicking on the input itself from triggering this again
                if (e.target !== fileInput) {
                    fileInput.click();
                }
            });
            
            // Prevent defaults for all drag events to enable drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });
            
            // Visual feedback when dragging over the zone
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });
            
            // Handle the dropped file
            dropZone.addEventListener('drop', handleDrop, false);
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight() {
                dropZone.classList.add('drag-over');
            }
            
            function unhighlight() {
                dropZone.classList.remove('drag-over');
            }
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    // Process only the first file if multiple are dropped
                    const file = files[0];
                    
                    // Check if it's a .lock file
                    if (file.name.endsWith('.lock')) {
                        // Update the file input value for consistency
                        // Note: This is limited by security, but we process the dropped file directly
                        processFile(file);
                    } else {
                        alert('Please upload a .lock file.');
                    }
                }
            }
        }
        
        /**
         * Processes the uploaded file - works for both regular upload and drag & drop
         */
        function processFile(file) {
            if (!file) {
                resetVisualization();
                return;
            }

            // Display the filename in the UI
            const fileInfo = document.getElementById('file-info');
            const fileName = document.getElementById('file-name');
            fileName.textContent = file.name;
            fileInfo.classList.add('active');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const result = parseUvLock(content);

                    // Prepare data for visualization
                    allData = result;
                    const nodeById = new Map(allData.nodes.map(n => [n.id, n]));
                    allData.edges.forEach(edge => {
                        edge.source = nodeById.get(edge.source);
                        edge.target = nodeById.get(edge.target);
                    });

                    // Hide placeholder and show visualization
                    document.getElementById('placeholder-message').style.display = 'none';
                    resetFilter();
                    setupAutocomplete();

                } catch (error) {
                    console.error("Error processing file:", error);
                    document.getElementById('stats').innerHTML = `<p>❌ Error processing file: ${error.message}</p>`;
                    resetVisualization();
                }
            };
            reader.onerror = () => {
                document.getElementById('stats').innerHTML = `<p>❌ Error reading file.</p>`;
                resetVisualization();
            };
            reader.readAsText(file);
        }

        // Update the file input handler to use the common processing function
        document.getElementById('file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            processFile(file);
        });

        /**
         * Parses uv.lock file content and converts it to a nodes/edges format.
         */
        function parseUvLock(content) {
            // Split content by package definitions. The first part is the header.
            const parts = content.split(/\n?\[\[package\]\]\n/);
            const package_blocks = parts.slice(1);

            const nodes = [];
            const edges = [];

            for (const block of package_blocks) {
                if (!block.trim()) continue;

                // Extract package name
                const nameMatch = block.match(/name = "([^"]+)"/);
                if (!nameMatch) continue;
                const packageName = nameMatch[1];

                // Extract version
                const versionMatch = block.match(/version = "([^"]+)"/);
                const version = versionMatch ? versionMatch[1] : "unknown";

                // Extract source information
                let sourceType = "unknown";
                let sourceUrl = "";
                const sourceMatch = block.match(/source = \{([^}]+)\}/s); // 's' flag for multiline
                if (sourceMatch) {
                    const sourceContent = sourceMatch[1];
                    if (sourceContent.includes("registry")) {
                        sourceType = "registry";
                        const registryMatch = sourceContent.match(/registry = "([^"]+)"/);
                        if (registryMatch) sourceUrl = registryMatch[1];
                    } else if (sourceContent.includes("git")) {
                        sourceType = "git";
                        const gitMatch = sourceContent.match(/git = "([^"]+)"/);
                        if (gitMatch) sourceUrl = gitMatch[1];
                    }
                }

                // Extract dependencies
                const dependencies = [];
                const depsSection = block.match(/dependencies = \[(.*?)\]/s);
                if (depsSection) {
                    const depsContent = depsSection[1];
                    // Use matchAll with a global flag to find all occurrences
                    const depMatches = depsContent.matchAll(/\{ name = "([^"]+)"/g);
                    for (const match of depMatches) {
                        dependencies.push(match[1]);
                    }
                }

                // Create node
                const node = {
                    id: packageName,
                    name: packageName,
                    version: version,
                    source_type: sourceType,
                    source_url: sourceUrl,
                    dependency_count: dependencies.length
                };
                nodes.push(node);

                // Create edges
                for (const dep of dependencies) {
                    const edge = {
                        source: packageName, // who depends
                        target: dep,         // on whom
                        relationship: 'depends_on'
                    };
                    edges.push(edge);
                }
            }

            return {
                nodes: nodes,
                edges: edges,
                metadata: {
                    total_packages: nodes.length,
                    total_dependencies: edges.length,
                    description: 'Dependency graph from uv.lock file'
                }
            };
        }

        function resetVisualization() {
            document.getElementById('placeholder-message').style.display = 'block';
            
            // Hide the file info
            const fileInfo = document.getElementById('file-info');
            fileInfo.classList.remove('active');
            
            if (simulation) {
                simulation.stop();
                updateVisualization({ nodes: [], edges: [] });
            }
        }

        function initializeVisualization() {
            const svgElement = document.getElementById('dependency-graph');
            const containerElement = document.getElementById('visualization-container');
            
            // Get dimensions from container
            const width = containerElement.clientWidth;
            const height = 600; // Set a default height
            
            svg = d3.select("#dependency-graph")
                .attr("width", width)
                .attr("height", height);

            svg.selectAll("*").remove();
            
            const defs = svg.append("defs");
            defs.append("marker").attr("id", "arrowhead").attr("viewBox", "0 -5 10 10").attr("refX", 8).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("class", "arrowhead");
            defs.append("marker").attr("id", "arrowhead-outgoing").attr("viewBox", "0 -5 10 10").attr("refX", 8).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("class", "arrowhead-outgoing");
            defs.append("marker").attr("id", "arrowhead-incoming").attr("viewBox", "0 -5 10 10").attr("refX", 8).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("class", "arrowhead-incoming");

            // Initialize zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => {
                    container.attr("transform", event.transform);
                });
            
            // Apply zoom and set initial transform to center the view
            svg.call(zoom);
            
            // Create the main container for all visualization elements
            container = svg.append("g")
                .attr("transform", `translate(${width/2}, ${height/2})`); // Start centered
            
            link = container.append("g").attr("class", "links").selectAll(".link");
            node = container.append("g").attr("class", "nodes").selectAll(".node");
            labels = container.append("g").attr("class", "labels").selectAll(".node-label");

            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(0, 0)) // Center at origin since container is translated
                .force("collision", d3.forceCollide().radius(40))
                .on("tick", ticked);
            
            // Set initial transform
            const initialTransform = d3.zoomIdentity.translate(width/2, height/2).scale(1);
            svg.call(zoom.transform, initialTransform);
            
            // Add window resize handler
            window.addEventListener('resize', function() {
                const newWidth = containerElement.clientWidth;
                svg.attr("width", newWidth);
                if (simulation) {
                    // Just restart simulation without changing center (it's already at 0,0)
                    simulation.alpha(0.1).restart();
                    
                    // Update the zoom transform to center the view
                    const newTransform = d3.zoomIdentity.translate(newWidth/2, height/2).scale(1);
                    svg.call(zoom.transform, newTransform);
                }
            });
        }

        function updateVisualization(data) {
            const oldNodePositions = new Map(simulation.nodes().map(d => [d.id, { x: d.x, y: d.y, fx: d.fx, fy: d.fy }]));
            data.nodes.forEach(d => {
                if (oldNodePositions.has(d.id)) {
                    Object.assign(d, oldNodePositions.get(d.id));
                }
            });

            node = node.data(data.nodes, d => d.id);
            node.exit().remove();
            node = node.enter().append("circle")
                .attr("class", d => `node source-type-${d.source_type}`)
                .attr("r", d => Math.max(5, Math.min(20, d.dependency_count * 2)))
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended))
                .on("click", handleNodeClick)
                .merge(node);

            link = link.data(data.edges, d => `${d.source.id}-${d.target.id}`);
            link.exit().remove();
            link = link.enter().append("line")
                .attr("class", "link")
                .merge(link);

            labels = labels.data(data.nodes, d => d.id);
            labels.exit().remove();
            labels = labels.enter().append("text")
                .attr("class", "node-label")
                .text(d => d.name)
                .attr("dy", ".35em")
                .merge(labels);

            const tooltip = d3.select("#tooltip");
            node.on("mouseover", function(event, d) {
                tooltip.style("opacity", 1).html(`<strong>${d.name}</strong><br/>version: ${d.version}<br/>type: ${d.source_type}<br/>dependencies: ${d.dependency_count}`).style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 10) + "px");
                link
                    .classed("outgoing", l => l.source.id === d.id)
                    .classed("incoming", l => l.target.id === d.id);
            }).on("mouseout", function() {
                tooltip.style("opacity", 0);
                link.classed("outgoing", false).classed("incoming", false);
            });

            simulation.nodes(data.nodes);
            simulation.force("link").links(data.edges);
            simulation.alpha(0.01).restart();
        }

        function ticked() {
            link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => {
                    const targetRadius = Math.max(5, Math.min(20, d.target.dependency_count * 2));
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                    return d.target.x - (dx / distance) * (targetRadius + 8);
                })
                .attr("y2", d => {
                    const targetRadius = Math.max(5, Math.min(20, d.target.dependency_count * 2));
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                    return d.target.y - (dy / distance) * (targetRadius + 8);
                });
            
            node.attr("cx", d => d.x).attr("cy", d => d.y);
            labels.attr("x", d => d.x).attr("y", d => d.y + 25);
        }
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.01).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function handleNodeClick(event, d) {
            if (clickAction === 'expand') {
                expandNode(d);
            } else {
                hideNode(d);
            }
        }

        function expandNode(clickedNode) {
            const displayedNodeIds = new Set(displayedData.nodes.map(n => n.id));
            const nodesToAdd = [];

            // Find neighbors of the clicked node that are not yet displayed.
            allData.edges.forEach(edge => {
                if (edge.source.id === clickedNode.id && !displayedNodeIds.has(edge.target.id)) {
                    if (!nodesToAdd.some(n => n.id === edge.target.id)) {
                        nodesToAdd.push(edge.target);
                    }
                } else if (edge.target.id === clickedNode.id && !displayedNodeIds.has(edge.source.id)) {
                    if (!nodesToAdd.some(n => n.id === edge.source.id)) {
                        nodesToAdd.push(edge.source);
                    }
                }
            });

            if (nodesToAdd.length > 0) {
                // Give new nodes an initial position near the clicked node to avoid chaotic entry.
                nodesToAdd.forEach(n => {
                    n.x = clickedNode.x + (Math.random() - 0.5) * 10;
                    n.y = clickedNode.y + (Math.random() - 0.5) * 10;
                });
                
                // Add the new nodes to our displayed data.
                nodesToAdd.forEach(n => displayedData.nodes.push(n));
                
                // After adding new nodes, rebuild the list of edges that should be visible.
                const allVisibleNodeIds = new Set(displayedData.nodes.map(n => n.id));
                const newEdges = allData.edges.filter(edge => 
                    allVisibleNodeIds.has(edge.source.id) && allVisibleNodeIds.has(edge.target.id)
                );
                
                displayedData.edges = newEdges;
                
                updateVisualization(displayedData);
            }
        }
        
        function hideNode(clickedNode) {
            // Remove the clicked node
            displayedData.nodes = displayedData.nodes.filter(n => n.id !== clickedNode.id);
            
            // Remove edges connected to the clicked node
            const clickedNodeId = clickedNode.id;
            displayedData.edges = displayedData.edges.filter(e => 
                e.source.id !== clickedNodeId && e.target.id !== clickedNodeId
            );
            
            updateVisualization(displayedData);
        }

        function filterDependencies() {
            const packageName = document.getElementById("packageFilter").value.trim().toLowerCase();
            if (!packageName || !allData) return;
            
            const targetNode = allData.nodes.find(n => n.name.toLowerCase().includes(packageName));
            if (!targetNode) {
                alert("未找到匹配的包名");
                return;
            }
            
            const connectedNodeIds = new Set([targetNode.id]);
            
            // Find all direct neighbors of the target node
            allData.edges.forEach(edge => {
                if (edge.source.id === targetNode.id) {
                    connectedNodeIds.add(edge.target.id);
                }
                if (edge.target.id === targetNode.id) {
                    connectedNodeIds.add(edge.source.id);
                }
            });
            
            const filteredNodes = allData.nodes.filter(node => connectedNodeIds.has(node.id));
            
            // After identifying all nodes to be displayed, find all edges between them.
            const relevantEdges = allData.edges.filter(edge => 
                connectedNodeIds.has(edge.source.id) && connectedNodeIds.has(edge.target.id)
            );
            
            displayedData = {
                nodes: filteredNodes,
                edges: relevantEdges
            };

            updateVisualization(displayedData);
            hideDropdown();
        }
        
        function resetFilter() {
            document.getElementById("packageFilter").value = "";
            hideDropdown();
            if (allData) {
                displayedData = {
                    nodes: [...allData.nodes],
                    edges: [...allData.edges]
                };
                updateVisualization(displayedData);
            }
        }
        
        // Allow Enter key to trigger filter
        document.getElementById("packageFilter").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                filterDependencies();
            }
        });

        /**
         * Downloads the current visualization as a PNG file.
         */
        function downloadVisualization() {
            const svgElement = document.getElementById('dependency-graph');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            // Set canvas dimensions
            const width = svgElement.clientWidth;
            const height = svgElement.clientHeight;
            canvas.width = width;
            canvas.height = height;

            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                
                // Now the SVG is rendered on the canvas, we can download it as an image
                const link = document.createElement('a');
                link.download = 'visualization.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            };
            
            // Convert SVG string to data URL
            const svgData = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
            img.src = svgData;
        }
    </script>
</body></html>
